name: Daily Auto Build (YouTube & Music)
on:
  schedule:
    # Roda todo dia √†s 10:00 UTC
    - cron: '0 10 * * *'
  workflow_dispatch: {}

permissions:
  contents: write # Para criar releases e commitar na branch 'update'
  actions: read

jobs:
  build-and-release:
    runs-on: ubuntu-latest
    timeout-minutes: 45

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: true
          fetch-depth: 0 # Necess√°rio para o git-auto-commit funcionar corretamente

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: "zulu"
          java-version: "17"

      - name: Get Last Build Info
        id: last_build
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Pega a tag da √∫ltima release para incrementar e o corpo para compara√ß√£o
          LAST_RELEASE=$(gh release view --json tagName,body --jq '{tagName: .tagName, body: .body}' || echo '{"tagName":"0","body":""}')
          LAST_TAG=$(echo "$LAST_RELEASE" | jq -r '.tagName')
          LAST_BODY=$(echo "$LAST_RELEASE" | jq -r '.body')

          # Extrai as vers√µes dos apps da √∫ltima release
          LAST_BUILT_YT=$(echo "$LAST_BODY" | grep -oP 'YouTube: `\K[0-9.]+' || echo "0")
          LAST_BUILT_MUSIC=$(echo "$LAST_BODY" | grep -oP 'Music: `\K[0-9.]+' || echo "0")
          LAST_MSG_ID=$(echo "$LAST_BODY" | grep -oP 'TG_MSG_ID: \K[0-9]+' || echo "")
          
          echo "last_tag=$LAST_TAG" >> $GITHUB_OUTPUT
          echo "last_built_yt=$LAST_BUILT_YT" >> $GITHUB_OUTPUT
          echo "last_built_music=$LAST_BUILT_MUSIC" >> $GITHUB_OUTPUT
          echo "last_msg_id=$LAST_MSG_ID" >> $GITHUB_OUTPUT
          echo "next_ver_code=$((LAST_TAG + 1))" >> $GITHUB_OUTPUT

      - name: Check for Updates via Build Script
        id: check_updates
        run: |
          # Roda o script em modo "config-update" para gerar um JSON com as vers√µes mais recentes
          UPDATE_CFG=$(./build.sh config.toml --config-update || echo "")
          
          if [[ -z "$UPDATE_CFG" ]]; then
            echo "Falha ao obter a configura√ß√£o de atualiza√ß√£o do script de build."
            echo "should_build_any=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "$UPDATE_CFG" > config.json
          
          # Extrai as novas vers√µes do JSON gerado
          NEW_YT_VERSION=$(jq -r '.YouTube.version // "0"' config.json)
          NEW_MUSIC_VERSION=$(jq -r '.Music.version // "0"' config.json)
          
          echo "new_yt_version=$NEW_YT_VERSION" >> $GITHUB_OUTPUT
          echo "new_music_version=$NEW_MUSIC_VERSION" >> $GITHUB_OUTPUT
          
          # Compara com as vers√µes antigas para decidir se compila
          SHOULD_BUILD_YT=false
          if [[ "$NEW_YT_VERSION" != "${{ steps.last_build.outputs.last_built_yt }}" && "$NEW_YT_VERSION" != "0" ]]; then
            SHOULD_BUILD_YT=true
          fi

          SHOULD_BUILD_MUSIC=false
          if [[ "$NEW_MUSIC_VERSION" != "${{ steps.last_build.outputs.last_built_music }}" && "$NEW_MUSIC_VERSION" != "0" ]]; then
            SHOULD_BUILD_MUSIC=true
          fi
          
          if [[ "$SHOULD_BUILD_YT" == "true" || "$SHOULD_BUILD_MUSIC" == "true" ]]; then
            echo "should_build_any=true" >> $GITHUB_OUTPUT
          else
            echo "should_build_any=false" >> $GITHUB_OUTPUT
          fi

      - name: Exit if no updates
        if: steps.check_updates.outputs.should_build_any != 'true'
        run: echo "Nenhuma atualiza√ß√£o de vers√£o detectada. Finalizando."

      - name: Build Apps
        if: steps.check_updates.outputs.should_build_any == 'true'
        run: ./build.sh config.json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          NEXT_VER_CODE: ${{ steps.last_build.outputs.next_ver_code }}

      - name: Prepare Release Content
        if: steps.check_updates.outputs.should_build_any == 'true'
        id: release_content
        run: |
          # Captura o changelog gerado pelo build script
          CHANGELOG=$(cat build.md)
          # Adiciona as vers√µes dos apps para o corpo da release
          YT_VERSION=$(ls build/youtube-revanced-v*.apk 2>/dev/null | grep -oP 'v\K[0-9.]+' | head -1 || echo "${{ steps.last_build.outputs.last_built_yt }}")
          MUSIC_VERSION=$(ls build/music-revanced-v*.apk 2>/dev/null | grep -oP 'v\K[0-9.]+' | head -1 || echo "${{ steps.last_build.outputs.last_built_music }}")
          
          BODY=$(cat <<EOF
          YouTube: \`${YT_VERSION}\`
          Music: \`${MUSIC_VERSION}\`

          ---
          ### Changelog
          ${CHANGELOG}
          EOF
          )
          
          # Passa o corpo e o changelog para os pr√≥ximos passos
          echo "body<<EOF" >> $GITHUB_OUTPUT
          echo "$BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT


      - name: Send Telegram Notification
        if: success() && steps.check_updates.outputs.should_build_any == 'true'
        id: telegram
        env:
          TG_TOKEN: ${{ secrets.TG_TOKEN }}
          TG_CHAT_ID: ${{ secrets.TG_CHAT_ID }}
        run: |
          cd build || { echo "Pasta 'build' n√£o encontrada"; exit 1; }
          
          NL=$'\n'
          APKS=""
          MODULES=""
          TAG="${{ steps.last_build.outputs.next_ver_code }}"
          BASE_URL="${{ github.server_url }}/${{ github.repository }}/releases/download/${TAG}"
          
          for OUTPUT in *; do
            if [[ $OUTPUT == *.apk ]]; then
              APKS+="${NL}üì¶ [${OUTPUT}](${BASE_URL}/${OUTPUT})"
            elif [[ $OUTPUT == *.zip ]]; then
              MODULES+="${NL}üì¶ [${OUTPUT}](${BASE_URL}/${OUTPUT})"
            fi
          done
          
          BODY="${{ steps.release_content.outputs.changelog }}"
          # Formata o changelog para o Telegram
          FORMATTED_BODY=$(echo "$BODY" | sed 's/^\* \*\*/‚Ü™ \*\*/g; s/^\* `/‚Ü™ \*\*/g; s/`/\*/g; s/^\* /\‚Ü™/g; s/\*\*/\*/g; s/###//g; s/^- /‚Ü™ /g; /^==/d;')
          
          MSG="*Build #${TAG} dispon√≠vel!*${NL}${NL}${FORMATTED_BODY}${NL}${NL}*‚ñº Downloads*${NL}"
          if [[ -n "$MODULES" ]]; then MSG+="*M√≥dulos:*${MODULES}${NL}"; fi
          if [[ -n "$APKS" ]]; then MSG+="*APKs:*${APKS}${NL}"; fi
          
          # Envia a mensagem e captura o ID
          RESPONSE=$(curl -s -X POST "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" \
            --data-urlencode "chat_id=${TG_CHAT_ID}" \
            --data-urlencode "text=${MSG}" \
            --data-urlencode "parse_mode=Markdown" \
            --data-urlencode "disable_web_page_preview=true")
          
          MSG_ID=$(echo "$RESPONSE" | grep -oP '"message_id":\K[0-9]+' || echo "")
          [ -n "$MSG_ID" ] && echo "msg_id=$MSG_ID" >> $GITHUB_OUTPUT

          # Apaga a mensagem anterior
          LAST_MSG_ID="${{ steps.last_build.outputs.last_msg_id }}"
          if [[ -n "$LAST_MSG_ID" ]]; then
            curl -s -X POST "https://api.telegram.org/bot${TG_TOKEN}/deleteMessage" \
              -d "chat_id=${TG_CHAT_ID}" \
              -d "message_id=${LAST_MSG_ID}" >/dev/null 2>&1 || true
          fi

      - name: Create Release and Upload Artifacts
        if: success() && steps.check_updates.outputs.should_build_any == 'true'
        uses: svenstaro/upload-release-action@v2
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          tag: ${{ steps.last_build.outputs.next_ver_code }}
          release_name: "Build #${{ steps.last_build.outputs.next_ver_code }}"
          body: |
            ${{ steps.release_content.outputs.body }}

            ---
            TG_MSG_ID: ${{ steps.telegram.outputs.msg_id }}
          file: ./build/*
          file_glob: true
          overwrite: true

      - name: Update Magisk JSON Branch
        if: success() && steps.check_updates.outputs.should_build_any == 'true'
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          git fetch origin update || true
          git checkout -B update origin/update || git checkout -b update
          
          # Copia o changelog para a nova branch
          cp -f build.md build.md
          
          get_update_json() {
            echo "{
            \"version\": \"$1\",
            \"versionCode\": ${{ steps.last_build.outputs.next_ver_code }},
            \"zipUrl\": \"$2\",
            \"changelog\": \"https://raw.githubusercontent.com/$GITHUB_REPOSITORY/update/build.md\"
          }"
          }

          cd build || exit 1
          for OUTPUT in *magisk*.zip; do
            [ "$OUTPUT" = "*magisk*.zip" ] && continue
            ZIP_S=$(unzip -p "$OUTPUT" module.prop)
            if ! UPDATE_JSON=$(echo "$ZIP_S" | grep updateJson); then continue; fi
            UPDATE_JSON="${UPDATE_JSON##*/}"
            VER=$(echo "$ZIP_S" | grep version=)
            VER="${VER##*=}"
            DLURL="${{ github.server_url }}/${{ github.repository }}/releases/download/${{ steps.last_build.outputs.next_ver_code }}/${OUTPUT}"
            get_update_json "$VER" "$DLURL" >"../$UPDATE_JSON"
          done
          cd ..
          
          find . -maxdepth 1 -name "*-update.json" -print0 | xargs -0 git add
          git add build.md
          
          if ! git diff --staged --quiet; then
            git commit -m "Bump to build #${{ steps.last_build.outputs.next_ver_code }}"
            git push --force origin update
          else
            echo "Nenhuma mudan√ßa nos arquivos de atualiza√ß√£o."
          fi

      - name: Clean old releases
        if: always() && steps.check_updates.outputs.should_build_any == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release list --repo ${{ github.repository }} --limit 100 --json tagName | \
          jq -r '.[5:].[].tagName' | \
          xargs -r -I {} gh release delete {} --repo ${{ github.repository }} --yes --cleanup-tag

      - name: Notify on Failure
        if: failure() && steps.check_updates.outputs.should_build_any == 'true'
        env:
          TG_TOKEN: ${{ secrets.TG_TOKEN }}
          TG_CHAT_ID: ${{ secrets.TG_CHAT_ID }}
        run: |
          MSG="‚ùå *Falha no Build #${{ steps.last_build.outputs.next_ver_code }}*\n\nOcorreu um erro durante a compila√ß√£o.\n\n[Verificar logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})"
          curl -s -X POST "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" -d "chat_id=${TG_CHAT_ID}" -d "text=${MSG}" -d "parse_mode=Markdown"
