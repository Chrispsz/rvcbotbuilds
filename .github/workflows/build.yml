name: Reusable Build Workflow
on:
  workflow_call:

permissions:
  contents: write
  actions: read

jobs:
  build-and-release:
    runs-on: ubuntu-latest
    timeout-minutes: 45
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: true
          fetch-depth: 0 # Profundidade completa para manipula√ß√£o do hist√≥rico Git

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: "zulu"
          java-version: "17"

      - name: Get Last Build Info
        id: last_build
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          LAST_TAG=$(gh release list -L 1 | awk -F '\t' '{print $3}' | grep -oP '[0-9]+' || echo "0")
          NEXT_VER_CODE=$((LAST_TAG + 1))
          
          LAST_MSG_ID=""
          if [[ "$LAST_TAG" != "0" ]]; then
            BODY=$(gh release view "$LAST_TAG" --json body -q '.body' || echo "")
            LAST_MSG_ID=$(echo "$BODY" | grep -oP 'TG_MSG_ID: \K[0-9]+' || echo "")
          fi
          
          echo "next_ver_code=$NEXT_VER_CODE" >> $GITHUB_OUTPUT
          echo "last_msg_id=$LAST_MSG_ID" >> $GITHUB_OUTPUT

      - name: Build Apps
        run: |
          UPDATE_CFG=$(./build.sh config.toml --config-update)
          echo "$UPDATE_CFG" > config.json
          ./build.sh config.json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          NEXT_VER_CODE: ${{ steps.last_build.outputs.next_ver_code }}
          
      - name: Prepare Release and Telegram Content
        id: content
        run: |
          DELIM="$(openssl rand -hex 8)"
          echo "changelog<<${DELIM}" >> "$GITHUB_OUTPUT"
          cat build.md >> "$GITHUB_OUTPUT"
          echo "${DELIM}" >> "$GITHUB_OUTPUT"

      - name: Send Telegram Notification
        id: telegram
        if: success()
        env:
          TG_TOKEN: ${{ secrets.TG_TOKEN }}
          TG_CHAT_ID: ${{ secrets.TG_CHAT_ID }}
        run: |
          cd build || { echo "Pasta 'build' n√£o encontrada"; exit 1; }
          
          NL=$'\n'
          APKS=""
          MODULES=""
          TAG="${{ steps.last_build.outputs.next_ver_code }}"
          BASE_URL="${{ github.server_url }}/${{ github.repository }}/releases/download/${TAG}"
          
          for OUTPUT in *; do
            if [[ $OUTPUT == *.apk ]]; then
              APKS+="${NL}üì¶ [${OUTPUT}](${BASE_URL}/${OUTPUT})"
            elif [[ $OUTPUT == *.zip ]]; then
              MODULES+="${NL}üì¶ [${OUTPUT}](${BASE_URL}/${OUTPUT})"
            fi
          done
          
          BODY="${{ steps.content.outputs.changelog }}"
          FORMATTED_BODY=$(echo "$BODY" | sed 's/^\* \*\*/‚Ü™ \*\*/g; s/^\* `/‚Ü™ \*\*/g; s/`/\*/g; s/^\* /\‚Ü™/g; s/\*\*/\*/g; s/###//g; s/^- /‚Ü™ /g; /^==/d;')
          
          MSG="*Build #${TAG} dispon√≠vel!*${NL}${NL}${FORMATTED_BODY}${NL}${NL}*‚ñº Downloads*${NL}"
          if [[ -n "$MODULES" ]]; then MSG+="*M√≥dulos:*${MODULES}${NL}"; fi
          if [[ -n "$APKS" ]]; then MSG+="*APKs:*${APKS}${NL}"; fi
          
          RESPONSE=$(curl -s -X POST "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" \
            --data-urlencode "chat_id=${TG_CHAT_ID}" \
            --data-urlencode "text=${MSG}" \
            --data-urlencode "parse_mode=Markdown" \
            --data-urlencode "disable_web_page_preview=true")
          
          MSG_ID=$(echo "$RESPONSE" | grep -oP '"message_id":\K[0-9]+' || echo "")
          [ -n "$MSG_ID" ] && echo "msg_id=$MSG_ID" >> $GITHUB_OUTPUT

          LAST_MSG_ID="${{ steps.last_build.outputs.last_msg_id }}"
          if [[ -n "$LAST_MSG_ID" ]]; then
            curl -s -X POST "https://api.telegram.org/bot${TG_TOKEN}/deleteMessage" -d "chat_id=${TG_CHAT_ID}" -d "message_id=${LAST_MSG_ID}" >/dev/null 2>&1 || true
          fi

      - name: Create Release and Upload Artifacts
        if: success()
        uses: svenstaro/upload-release-action@v2
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          tag: ${{ steps.last_build.outputs.next_ver_code }}
          release_name: "Build #${{ steps.last_build.outputs.next_ver_code }}"
          body: |
            ${{ steps.content.outputs.changelog }}

            ---
            TG_MSG_ID: ${{ steps.telegram.outputs.msg_id }}
          file: ./build/*
          file_glob: true
          overwrite: true
      
      - name: Update Magisk JSON Branch
        if: success()
        run: |
          # Configura o Git com o nome e e-mail do bot para o commit
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          # Cria/reseta a branch 'update' localmente a partir do estado atual da 'main'
          git checkout -B update
          
          # Fun√ß√£o para gerar os arquivos JSON
          get_update_json() {
            echo "{
            \"version\": \"$1\",
            \"versionCode\": ${{ steps.last_build.outputs.next_ver_code }},
            \"zipUrl\": \"$2\",
            \"changelog\": \"https://raw.githubusercontent.com/$GITHUB_REPOSITORY/update/build.md\"
          }"
          }

          # Navega para a pasta de build, gera os JSONs e volta
          cd build || exit 1
          for OUTPUT in *magisk*.zip; do
            [ "$OUTPUT" = "*magisk*.zip" ] && continue
            ZIP_S=$(unzip -p "$OUTPUT" module.prop)
            if ! UPDATE_JSON=$(echo "$ZIP_S" | grep updateJson); then continue; fi
            UPDATE_JSON="${UPDATE_JSON##*/}"
            VER=$(echo "$ZIP_S" | grep version=)
            VER="${VER##*=}"
            DLURL="${{ github.server_url }}/${{ github.repository }}/releases/download/${{ steps.last_build.outputs.next_ver_code }}/${OUTPUT}"
            get_update_json "$VER" "$DLURL" >"../$UPDATE_JSON"
          done
          cd ..
          
          # Copia o changelog para a raiz da branch
          cp -f build.md build.md
          
          # Adiciona todos os arquivos gerados (changelog e JSONs) ao Git
          git add build.md ./*-update.json
          
          # Faz o commit apenas se houver mudan√ßas
          if ! git diff --staged --quiet; then
            git commit -m "chore: Bump to build #${{ steps.last_build.outputs.next_ver_code }}"
            # FOR√áA o push para a branch 'update', sobrescrevendo seu hist√≥rico.
            # Isso previne erros de diverg√™ncia e mant√©m a branch sempre limpa.
            git push origin update --force
          else
            echo "Nenhuma mudan√ßa nos arquivos de atualiza√ß√£o. Pulando o commit."
          fi
          
      - name: Clean old releases
        if: always()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release list --repo ${{ github.repository }} --limit 100 --json tagName | \
          jq -r '.[5:].[].tagName' | \
          xargs -r -I {} gh release delete {} --repo ${{ github.repository }} --yes --cleanup-tag

      - name: Notify on Failure
        if: failure()
        env:
          TG_TOKEN: ${{ secrets.TG_TOKEN }}
          TG_CHAT_ID: ${{ secrets.TG_CHAT_ID }}
        run: |
          MSG="‚ùå *Falha no Build #${{ steps.last_build.outputs.next_ver_code }}*\n\nOcorreu um erro durante a compila√ß√£o.\n\n[Verificar logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})"
          curl -s -X POST "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" -d "chat_id=${TG_CHAT_ID}" -d "text=${MSG}" -d "parse_mode=Markdown"
